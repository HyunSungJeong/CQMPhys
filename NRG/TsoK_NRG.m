function TsoK_NRG(parfn,varargin)
  setenv('RC_STORE', go('rcs'));      % '/project/hyunsung/RCStore'

  partot = job_func_preamble(parfn, varargin{:});

  [PE, Nkeep, J0, K0, I0, T, JobName, nz] = loadvar(partot, ...
    {'PE', 'Nkeep', 'J0', 'K0', 'I0', 'T', 'JobName', 'nz'}, ...
      {[], [], [], [], [], [], [], []});

  %num_threads_SL(8);
  
  disp2(['SLURM_JOB_NAME : ', getenv('SLURM_JOB_NAME')]);
  disp2(['SLURM_JOB_ID : ', getenv('SLURM_JOB_ID')]);
  disp2(['SLURM_ARRAY_JOB_ID : ', getenv('SLURM_ARRAY_JOB_ID')]);
  disp2(['SLURM_ARRAY_TASK_ID : ', getenv('SLURM_ARRAY_TASK_ID')]);
  disp2(['LOG_FILE : ', getenv('LOG_FILE')]);

  disp2(sprintf('%d',nz));

  % Impurity Hamiltonian parameters
  % J0 : spin-spin coupling
  % K0 : orbital - orbital coupling
  % I0 : spin-orbital coupling

  % T : Temperature
  D = 1;
  Delta = pi;
  ozin = [-1;1]*D;
  RhoV2in = [1;1]*(Delta/pi);

  % NRG parameters
  Lambda = 4;
  N = max(ceil(-2*log(T/100)/log(Lambda))+8,20);
  %nz = 2;    
  Etrunc = []; %9;
  ETRUNC = []; %inf(1,20);

  [ff, gg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));

  % local operators
  [FF,ZF,J_sp,IF] = getLocalSpace('FermionS','Acharge,SU2spin,SU2channel','NC',2);
  [Fs,Zs,J_sp,Es] = setItag('s00','op',FF(:),ZF,J_sp(:),IF.E);
  J_sp = -J_sp;   % spin operator generated by getLocalSpace and quadOp differs by sign!
  Ns = quadOp(Fs,Fs,[]);

  J_orb = quadOp(Fs,Fs,[0,0,2]);

  J_sp_orb = quadOp(Fs,Fs,[0,2,2]);
  J_sp_orb = J_sp_orb/2;

  F_imp = getsub(FF,1);
  Z_imp = getsub(ZF,2);
  E_imp = getsub(IF.E,2);
  S_sp = getsub(J_sp,1);
  S_orb = getsub(J_orb,1);
  [F_imp,Z_imp,E_imp,S_sp,S_orb] = setItag('L00','op',F_imp(:),Z_imp(:),E_imp,S_sp(:),S_orb(:));
  N_imp = quadOp(F_imp,F_imp,[]);
  
  S_sp_orb = quadOp(F_imp,F_imp,[0,0,2]);
  S_sp_orb = S_sp_orb/2;

  % local isometry and Hamiltonian
  A0 = getIdentity(E_imp,2,Es,2,'K00*',[1,3,2]);

  H0 = J0*contract(A0,'!2*',{J_sp,'!2*',{S_sp,A0}});              % spin-spin
  H0 = H0 + K0*contract(A0,'!2*',{J_orb,'!2*',{S_orb,A0}});       % orbital-orbital
  A = getIdentity(S_sp,3,S_orb,3,'op*');
  H0 = H0 + I0*contract(A0,'!2*',{contract(A,'1,2',contract(S_sp,'!3',S_orb,'!2'),'2,4'),'!2',{A0,J_sp_orb,'!2*'}});  % spin-orbital
  H0 = H0 + 1e-40*contract(A0,'!2*',A0);

  % operators that define the two-point correlators
  Ops1 = [S_sp; S_orb; S_sp_orb];% J_sp; J_orb; J_sp_orb];
  Ops2 = Ops1;
  OpNames = {'ImpSp','ImpOrb','ImpSpOrb'};%,'BathSp','BathOrb','BathSpOrb'};

  % zflag and cflag are options in getAdisc(fdmNRG calc. of the spectral func. of the correlation function)
  % zflag: to use(1) or not to use(0) fermionic sign change for each operator.
  % 1 for fermionic operators, 0 for bosonic operators (e.g. if Ops1 = [fermionic, bosonic], zflag = [1,0]
  zflag = zeros(1,numel(Ops1));     
  % cflag: sign factors for each commutator(+ for fermionic, - for bosonic operators)
  % corresponds to the purple sign factor in lecture note 16.2 of tensor networks course
  cflag = (zflag-0.5)*2;

  STG = ['/data/',getenv('USER'),'/TsoK/',JobName,'_Nkeep=',sprintf('%.15g',Nkeep)];
  %STG = ['/data/',getenv('USER'),'/TsoK/TEST_Nk=3000_',JobName];

  Adiscs = cell(numel(Ops1),nz); % discrete data
  Aconts = cell(1,size(Adiscs,1)); % continuous (i.e., broadened) spectral function

  for itz = (1:nz)
    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz}(2:end),FF,ZF,'Nkeep',Nkeep,'deps',1e-10);

    if itz == nz
      [Etot,Qtot,Qdiff] = plotE(nrgdata,'Emax',10,'legmax',25);       % Data for Eflow diagram

      save([STG,'/Etot.mat'],'Etot');
      save([STG,'/Qtot.mat'],'Qtot');
    end

    nrgdata = getRhoFDM(nrgdata,T,'-v','Rdiag',true);   % calculating the full density matrix(FDM)

    [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata,Ops1,Ops2,ZF,'Z_L00',Z_imp,'zflag',zflag,'cflag',cflag,'emin',T);
    % odisc: [Numeric vector] center values of the frequency grid
    % sigmak [Numeric vector] center values of the broadening width bins
    % Adiscs: [cell array of numeric matrix] spectral function binned along odisc
    % Adiscs(:,itz): cell vector of numeric matrix. 
    % nth matrix Adiscs(n,itz) corresponds to spectral function of Ops1(n) and Ops2(n) binned along odisc and sigmak
    % Length of cell vector Adisc(:,itz): numel(Ops1) = numel(Ops2)
  end

  save([STG,'/odisc_nz=',sprintf('%d',nz),'.mat'],'odisc');

  % file path to save Aconts
  SaveAconts = cellfun(@(x) [STG,'/NRG_Op=',OpNames{x},'.mat'], num2cell(1:numel(Ops1)), 'UniformOutput', false);
  SaveAdiscs = cellfun(@(x) [STG,'/Adiscs_NRG_Op=',OpNames{x},'_nz=',sprintf('%d',nz),'.mat'], num2cell(1:numel(Ops1)), 'UniformOutput', false);

  % Calculate dynamic susceptibilities
  for ita = (1:size(Adiscs,1))

    Adisc = mean(cell2mat(reshape(Adiscs(ita,:),[1 1 nz])),3);
    save(SaveAdiscs{ita},'Adisc');

    [ocont, Aconts{ita}] = getAcont(odisc,Adisc,sigmak,T/5,'alphaz',1/nz,'emin',T);
    % ocont : [numeric vector] Logarithimic frequency grid.
    % Aconts : [numeric vector] Smoothened spectral function.

    temp = Aconts{ita};
    save(SaveAconts{ita},'temp');
  end
  save([STG,'/ocont.mat'],'ocont');


  %% calculate correlation functions between impurity and Wilson chain sites

  Imp_sp_sq = contract(S_sp,'!2*',S_sp);        % Square of the impurity spin operator
  Imp_orb_sq = contract(S_orb,'!2*',S_orb);     % Square of the impurity orbital psuedospin operator
  Sp_corr = cell(N,2);        % cell array of spin-spin correlators between the impurity and Wilson chain sites
  Orb_corr = cell(N,2);       % cell array of orb-orb correlators between the impurity and Wilson chain sites
                              % 1: product of spin(orbital psuedospin) square / 2: inner product between spins(orbital psuedospins)
  
  Sp_corr_Left{1} = Imp_sp_sq;
  Sp_corr_Left{2} = S_sp;
  Orb_corr_Left{1} = Imp_orb_sq;
  Orb_corr_Left{2} = S_orb;
  
  for site = (0:N-2)
    disptime(['Calculating correlator between impurity and Wilson chain site #',sprintf('%02d',site)]);
  
    Wilson_sp = setItag(['s',sprintf('%02d',site)],'op',J_sp);      % spin operator on Wilson chain site of interest
    Wilson_orb = setItag(['s',sprintf('%02d',site)],'op',J_orb);    % orbital psuedospin operator on Wilson chain site of interest
    Wilson_sp_sq = contract(Wilson_sp,'!2*',Wilson_sp);             % square of the spin operator on Wilson chain site
    Wilson_orb_sq = contract(Wilson_orb,'!2*',Wilson_orb);          % square of the orbital psuedospin operator on Wilson chain site
      
    if site > 0
      Sp_corr_Left{1} = contract(Sp_corr_Left{1},'!1',nrgdata.AK{site});
      Sp_corr_Left{1} = contract(nrgdata.AK{site},'!2*',Sp_corr_Left{1},'!2');
      Orb_corr_Left{1} = contract(Orb_corr_Left{1},'!1',nrgdata.AK{site});
      Orb_corr_Left{1} = contract(nrgdata.AK{site},'!2*',Orb_corr_Left{1},'!2');
  
      Sp_corr_Left{2} = contract(Sp_corr_Left{2},'!1',nrgdata.AK{site});
      Sp_corr_Left{2} = contract(nrgdata.AK{site},'!2*',Sp_corr_Left{2},[1,3,2]);
      Orb_corr_Left{2} = contract(Orb_corr_Left{2},'!1',nrgdata.AK{site});
      Orb_corr_Left{2} = contract(nrgdata.AK{site},'!2*',Orb_corr_Left{2},[1,3,2]);
    end
  
    Sp_corrT{1} = contract(Sp_corr_Left{1},'!1',nrgdata.AT{site+1},'!2');
    Sp_corrT{1} = contract(Sp_corrT{1},Wilson_sp_sq);
    Sp_corrT{1} = contract(nrgdata.AT{site+1},'!2*',Sp_corrT{1});
  
    Sp_corrK{1} = contract(Sp_corr_Left{1},'!1',nrgdata.AK{site+1},'!2');
    Sp_corrK{1} = contract(Sp_corrK{1},Wilson_sp_sq);
    Sp_corrK{1} = contract(nrgdata.AK{site+1},'!2*',Sp_corrK{1});
  
  
    Orb_corrT{1} = contract(Orb_corr_Left{1},'!1',nrgdata.AT{site+1},'!2');
    Orb_corrT{1} = contract(Orb_corrT{1},Wilson_orb_sq);
    Orb_corrT{1} = contract(nrgdata.AT{site+1},'!2*',Orb_corrT{1});
  
    Orb_corrK{1} = contract(Orb_corr_Left{1},'!1',nrgdata.AK{site+1},'!2');
    Orb_corrK{1} = contract(Orb_corrK{1},Wilson_orb_sq);
    Orb_corrK{1} = contract(nrgdata.AK{site+1},'!2*',Orb_corrK{1});
  
  
    Sp_corrT{2} = contract(Sp_corr_Left{2},'!1',nrgdata.AT{site+1},'!2');
    Sp_corrT{2} = contract(Sp_corrT{2},conj(Wilson_sp));
    Sp_corrT{2} = contract(nrgdata.AT{site+1},'!2*',Sp_corrT{2});
  
    Sp_corrK{2} = contract(Sp_corr_Left{2},'!1',nrgdata.AK{site+1},'!2');
    Sp_corrK{2} = contract(Sp_corrK{2},conj(Wilson_sp));
    Sp_corrK{2} = contract(nrgdata.AK{site+1},'!2*',Sp_corrK{2});
  
  
    Orb_corrT{2} = contract(Orb_corr_Left{2},'!1',nrgdata.AT{site+1},'!2');
    Orb_corrT{2} = contract(Orb_corrT{2},conj(Wilson_orb));
    Orb_corrT{2} = contract(nrgdata.AT{site+1},'!2*',Orb_corrT{2});
  
    Orb_corrK{2} = contract(Orb_corr_Left{2},'!1',nrgdata.AK{site+1},'!2');
    Orb_corrK{2} = contract(Orb_corrK{2},conj(Wilson_orb));
    Orb_corrK{2} = contract(nrgdata.AK{site+1},'!2*',Orb_corrK{2});
  
    for it = (1:2)
      Sp_corr{site+1,it} = 0;
      corrT = contract(Sp_corrT{it}, diag(nrgdata.RhoT{site+1}));
      corrK = contract(Sp_corrK{it}, nrgdata.RhoK{site+1});
      if ~isempty(corrT)
        Sp_corr{site+1,it} = Sp_corr{site+1,it} + corrT.data{1};
      end
      if ~isempty(corrK)
        Sp_corr{site+1,it} = Sp_corr{site+1,it} + corrK.data{1};
      end
  
      Orb_corr{site+1,it} = 0;
      corrT = contract(Orb_corrT{it}, diag(nrgdata.RhoT{site+1}));
      corrK = contract(Orb_corrK{it}, nrgdata.RhoK{site+1});
      if ~isempty(corrT)
        Orb_corr{site+1,it} = Orb_corr{site+1,it} + corrT.data{1};
      end
      if ~isempty(corrK)
        Orb_corr{site+1,it} = Orb_corr{site+1,it} + corrK.data{1};
      end
    end

  end

  save([STG,'/spin_spin_correlators.mat'],'Sp_corr');
  save([STG,'/orbital_orbital_correlators.mat'],'Orb_corr');
  %%%


  beta = 1.5;
  Sent_bath = load(['/data/',getenv('USER'),'/bathNRG/Lambda=',sprintf('%.15g',Lambda),'_Nkeep=',sprintf('%.15g',Nkeep), ...
                        '/Sent_MinT=1e-30_beta=',sprintf('%.2f',beta),'.mat']);
  field = fieldnames(Sent_bath);
  Sent_bath = getfield(Sent_bath,field{1});
  
  [Temps,TchiS,Csh,Sent,TchiC,Sz,Cz] = getTDconv(nrgdata,'useT','beta',1.5);
  Sent = Sent(Temps > T);
  Sent_bath = Sent_bath(Temps > T);
  Sent_imp = Sent - Sent_bath;
  Temps = Temps(Temps > T);
  save([STG,'/Temps.mat'],'Temps');
  save([STG,'/Sent_imp.mat'],'Sent_imp');
  
end