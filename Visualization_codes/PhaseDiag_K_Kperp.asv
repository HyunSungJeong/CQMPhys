function PhaseDiag_K_Kperp(J0, I0)
    
    useEnt = true;

    %% Load the selected data folder
    path = 'C:\Users\hsjun\OneDrive\Physics\Research\data\TsoK_Aniso_selected';
    FileInfo = dir(path);

    %% Make a list of the names of data folders
    DataFolders = cell(1,numel(FileInfo));      % names of folders that hold data
    cnt = 1;
    for it = 1:numel(FileInfo)      
        DirName = FileInfo(it).name;
        if DirName(1) == 'J'        % add new data folder to cell 'DataFolders'
            DataFolders{cnt} = DirName;
            cnt = cnt + 1;
        end
    end
    DataFolders = DataFolders(1:cnt-1);

    %% Extract available parameter sets from the data folder names
    J = zeros(1,numel(DataFolders));
    K_perp = J;
    K_z = J;
    I = J;
    T = J;
    for it = 1:numel(DataFolders)
        tmp = sscanf(DataFolders{it}, 'J0=%f_K_perp=%f_K_z=%f_I0=%f_T=%f');
        J(it) = tmp(1);
        K_perp(it) = tmp(2);
        K_z(it) = tmp(3);
        I(it) = tmp(4);
        T(it) = tmp(5);
    end

    %% Load data to be used for plotting
    RelevIdx = (J == J0) & (I == I0);       % Indices of folders that are relevant for plotting
    RelevData = DataFolders(RelevIdx);      % folder names of data that are relevant for plotting: ones that are (J, K) = (J0, K0)
    J = J(RelevIdx);                        % parameters 'J' that are available for plotting
    N_Relev = numel(RelevData);             % number of relevant data

    ocont = cell(1,numel(RelevData));
    ImpSp = ocont;
    ImpOrb_plus = ocont;
    ImpOrb_z = ocont;
    Sent = ocont;
    DiscData = ocont;

    for itSub = 1:numel(RelevData)        % for all data with relevant parameters
        DataPath = [path, filesep, RelevData{itSub}];
        FileInfo = dir(DataPath);

        for itD = 1:numel(FileInfo)     % load impurity susceptibilities and entropy for each relevant parameter

                switch FileInfo(itD).name
                    case 'ocont.mat'
                        tmp = load([DataPath,'\ocont.mat']);
                        field = fieldnames(tmp);
                        ocont{itSub} = getfield(tmp, field{1});

                    case 'NRG_Op=ImpOrb_plus.mat'
                        tmp = load([DataPath,'\NRG_Op=ImpOrb_plus.mat']);
                        field = fieldnames(tmp);
                        ImpOrb_plus{itSub} = getfield(tmp, field{1});

                    case 'NRG_Op=ImpOrb_z.mat'
                        tmp = load([DataPath,'\NRG_Op=ImpOrb_z.mat']);
                        field = fieldnames(tmp);
                        ImpOrb_z{itSub} = getfield(tmp, field{1});

                    case 'NRG_Op=ImpSp.mat'
                        tmp = load([DataPath,'\NRG_Op=ImpSp.mat']);
                        field = fieldnames(tmp);
                        ImpSp{itSub} = getfield(tmp, field{1});

                    case 'DiscData.mat'
                        tmp = load([DataPath,'\DiscData.mat']);
                        field = fieldnames(tmp);
                        DiscData{itSub} = getfield(tmp, field{1});

                    case 'Temps.mat'
                        tmp = load([DataPath,'\Temps.mat']);
                        field = fieldnames(tmp);
                        Temps = getfield(tmp, field{1});

                    case 'Sent_imp_beta=1.5.mat'
                        tmp = load([DataPath,'\Sent_imp_beta=1.5.mat']);
                        field = fieldnames(tmp);
                        Sent{itSub} = getfield(tmp, field{1});

                end % switch - case
        end % itD

    end % itF

    %% extract impurity orbital_z dynamic susceptibility power law

    if ~useEnt
        fit_range = [-6.5, -3];
        Orbz_exp = zeros(1, N_Relev);
        OrbP_exp = zeros(1, N_Relev);
    
        for itD = 1:N_Relev
            
            log_T = log10(ocont{itD}(ocont{itD}>0));          % log temperatures
            log_Susc = log10(ImpOrb_z{itD}(ocont{itD}>0));
    
            log_Susc = log_Susc(log_T>fit_range(1) & log_T<fit_range(2));
            log_T = log_T(log_T>fit_range(1) & log_T<fit_range(2));
    
            % fit 
            f = polyfit(log_T, log_Susc, 1);
            Orbz_exp(itD) = f(1);
    
            log_T = log10(ocont{itD}(ocont{itD}>0));          % log temperatures
            log_Susc = log10(ImpOrb_plus{itD}(ocont{itD}>0));
    
            log_Susc = log_Susc(log_T>fit_range(1) & log_T<fit_range(2));
            log_T = log_T(log_T>fit_range(1) & log_T<fit_range(2));
    
            % fit 
            f = polyfit(log_T, log_Susc, 1);
            OrbP_exp(itD) = f(1);
    
        end

    end

    %% Plot phase diagram with entropy colormap
    figure;
    hold on;
    set(gca, 'XScale', 'linear', 'YScale', 'linear', 'FontSize', 18);
    set(gca, 'XTick', -0.2:0.08:0.2);
    set(gca, 'YTick', 0:0.02:0.2);
    set(gca, 'FontSize', 13);
    set(gca, 'LineWidth', 1);  % make axis lines (incl. ticks) bold
    set(gca, 'XMinorTick', 'on', 'YMinorTick', 'on');
    set(gca, 'MinorGridLineStyle', '-', 'MinorGridAlpha', 0.3);

    xlabel('$K_{z}$', 'Interpreter', 'latex', 'FontSize', 25);
    ylabel('$K_{\perp}$', 'Interpreter', 'latex', 'FontSize', 25);
            

    % define and plot colormap
    eps = 1e-5;
    Cmap = nan(41, 21);
    PB = zeros(3,21);   % K_perp at phase boundary

    for itz = 1:21
        PB_found = false(1,3);

        for itp = 1:41

            K_p = 0.005*itp - 0.005;
            idx = find(J == J0 & abs(K_perp-K_p) < eps & abs(K_z-0.02*itz+0.22) < eps);

            if useEnt
                if ~isempty(idx)
                    if ~isempty(Sent{idx})
                        Cmap(itp,itz) = exp(Sent{idx}(end));
                        
                        for itT = 1:3
                            if exp(Sent{idx}(30+30*itT)) < 2*sqrt(2) - 0.05 && ~PB_found(itT)
                                PB(itT,itz) = K_p;
                                PB_found(itT) = true;
                            end
                        end

                    else
                        Cmap(itp,itz) = 0;    
                    end
                end
            else
                %Cmap(itp, itz) = Orbz_exp(idx) - OrbP_exp(idx);
                Cmap(itp, itz) = Orbz_exp(idx);
                %Cmap(itp, itz) = OrbP_exp(idx);
            end 
        end
    end

    if useEnt
        for itz = 1:21
            for itp = 1:41

                K_p = 0.005*itp - 0.005;
                
                if Cmap(itp,itz) == 0 || isnan(Cmap(itp,itz))
                    step = 0.02;
                    min_val = 0;
                    max_val = 0.2;
                    
                    % Round to nearest multiple of 0.02
                    if K_p > PB(end,itz)
                        rounded = ceil(K_p/step) * step;
                    else
                        rounded = floor(K_p/step) * step;
                    end
                    
                    % Clamp within bounds
                    clamped = min(max(rounded, min_val), max_val);
                    itp_closest = round(clamped/0.005) + 1;

                    Cmap(itp,itz) = Cmap(itp_closest,itz);
                end

            end % itp
        end % itz
    end

    xlim([-0.2, 0.2]);
    ylim([0, 0.2]);

    patch_purple = [.937, .910, .973];
    line_purple = [.455, .165, .765];
    patch_teal = [.627, .843, .843];
    line_teal = [.180, .600, .600];
    
    % Number of steps
    n = 256;
    
    % Interpolation
    r = linspace(patch_purple(1), patch_teal(1), n)';
    g = linspace(patch_purple(2), patch_teal(2), n)';
    b = linspace(patch_purple(3), patch_teal(3), n)';
    
    custom_cmap = [r, g, b];

    [arrow_X, arrow_Y] = meshgrid(-0.21:0.02:0.21, -0.0025:0.005:0.2025);
    Z = ones(size(arrow_X));  % some positive number for height
    surf(arrow_X, arrow_Y, Z, Cmap, 'EdgeColor', 'none');
    shading flat;      
    colormap(custom_cmap);
    cb = colorbar;
    ylabel(cb, '$\exp(S_{\mathrm{imp}})$', 'Interpreter', 'latex', 'FontSize', 18);

    cb.Ticks = [2:0.1:2.7, 2*sqrt(2)];
    cb.TickLabels = {'$2$', '$2.1$', '$2.2$', '$2.3$', '$2.4$', '$2.4$', '$2.6$', '$2.7$', '$2 \sqrt{2}$'};
    set(cb, 'TickLabelInterpreter', 'latex');

    Kz = -0.2:0.02:0.2;
    Z = 5*ones(1,21);
    legends = cell(1,4);
    handles = [];
    colors = [.929, .694, .125;
                .850, .325, .098;
                0, .447, .741];
    linestyles = {'--', '--', '-'};

    for itT = 1:3
        PB_now = PB(itT,:);
        hdl = plot3(Kz(PB_now>0), PB_now(PB_now>0), Z(PB_now>0), linestyles{itT}, 'Color', colors(itT,:), 'LineWidth', 2);
        handles = [handles,hdl];
        legends{itT} = ['$ \mathrm{Phase \ Boundary} \left( \ T = ', SciNot(sqrt(2.5)^-(30+30*itT)), '\right) $'];
    end

    %plot3(Kz(PB>0), PB(PB>0), Z(PB>0), '-', 'Color', 'red', 'LineWidth', 2);
    hdl = plot3(Kz, -Kz, Z, '--', 'Color', [.2,.2,.2], 'LineWidth', 1.5);
    handles = [handles, hdl];
    legends{4} = '$\mathrm{Phase \ Boundary \left( poor \ man''s \ scaling \right)}$';

    legend(handles, legends, 'Interpreter', 'latex', 'FontSize', 10);

    text_X = 0.04;
    text_Y = 0.12;
    text(text_X, text_Y, '$\mathrm{Fermi \ Liquid}$', 'Color', line_purple, 'Interpreter', 'latex', 'FontSize', 15);

    if useEnt
        clim([2,2*sqrt(2)]);            % Set color value limits
    else
        %clim([0,0.15]);
        clim([-1.2,-0.8]);
        %clim([-1.2,-0.8]);
    end

    view(2);
    set(gca, 'Layer', 'top');
    hold off;


end