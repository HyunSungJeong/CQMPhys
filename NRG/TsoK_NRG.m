function TsoK_NRG(parfn,varargin)

  try % in case of bug
    setenv('RC_STORE', go('rcs'));      % '/project/hyunsung/RCStore'

    partot = job_func_preamble(parfn, varargin{:});

    [PE, Nkeep, Lambda, J0, K0, I0, T, JobName, getSusc, getCorr, nz] = loadvar(partot, ...
      {'PE', 'Nkeep', 'Lambda', 'J0', 'K0', 'I0', 'T', 'JobName', 'getSusc', 'getCorr', 'nz'}, ...
        {[], [], [], [], [], [], [], [], [], [], []});

    %num_threads_SL(8);
    
    disp2(['SLURM_JOB_NAME : ', getenv('SLURM_JOB_NAME')]);
    disp2(['SLURM_JOB_ID : ', getenv('SLURM_JOB_ID')]);
    disp2(['SLURM_ARRAY_JOB_ID : ', getenv('SLURM_ARRAY_JOB_ID')]);
    disp2(['SLURM_ARRAY_TASK_ID : ', getenv('SLURM_ARRAY_TASK_ID')]);
    disp2(['LOG_FILE : ', getenv('LOG_FILE')]);

    disp2(sprintf('%d',nz));

    % Impurity Hamiltonian parameters
    % J0 : spin-spin coupling
    % K0 : orbital - orbital coupling
    % I0 : spin-orbital coupling

    % T : Temperature
    emin = T;
    D = 1;
    Delta = pi;
    ozin = [-1;1]*D;
    RhoV2in = [1;1]*(Delta/pi);

    % NRG parameters
    N = max(ceil(-2*log(T/100)/log(Lambda))+8,20);
    %nz = 2;    
    Etrunc = []; %9;
    ETRUNC = []; %inf(1,20);

    [ff, gg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));

    % local operators
    [FF,ZF,J_sp,IF] = getLocalSpace('FermionS','Acharge,SU2spin,SU2channel','NC',2);
    [Fs,Zs,J_sp,Es] = setItag('s00','op',FF(:),ZF,J_sp(:),IF.E);
    J_sp = -J_sp;   % spin operator generated by getLocalSpace and quadOp differs by sign!
    Ns = quadOp(Fs,Fs,[]);

    J_orb = quadOp(Fs,Fs,[0,0,2]);

    J_sp_orb = quadOp(Fs,Fs,[0,2,2]);
    J_sp_orb = J_sp_orb/2;

    F_imp = getsub(FF,1);
    Z_imp = getsub(ZF,2);
    E_imp = getsub(IF.E,2);
    S_sp = getsub(J_sp,1);
    S_orb = getsub(J_orb,1);
    [F_imp,Z_imp,E_imp,S_sp,S_orb] = setItag('L00','op',F_imp(:),Z_imp(:),E_imp,S_sp(:),S_orb(:));
    N_imp = quadOp(F_imp,F_imp,[]);
    
    S_sp_orb = quadOp(F_imp,F_imp,[0,2,2]);   % there was a typo! [0,0,2] should be [0,2,2]
    S_sp_orb = S_sp_orb/2;

    % local isometry and Hamiltonian
    A0 = getIdentity(E_imp,2,Es,2,'K00*',[1,3,2]);

    H0 = J0*contract(A0,'!2*',{J_sp,'!2*',{S_sp,A0}});              % spin-spin
    H0 = H0 + K0*contract(A0,'!2*',{J_orb,'!2*',{S_orb,A0}});       % orbital-orbital
    A = getIdentity(S_sp,3,S_orb,3,'op*');
    H0 = H0 + I0*contract(A0,'!2*',{contract(A,'1,2',contract(S_sp,'!3',S_orb,'!2'),'2,4'),'!2',{A0,J_sp_orb,'!2*'}});  % spin-orbital
    H0 = H0 + 1e-40*contract(A0,'!2*',A0);

    % operators that define the two-point correlators
    Ops1 = [S_sp; S_orb; S_sp_orb; J_sp; J_orb; J_sp_orb];
    Ops2 = Ops1;
    OpNames = {'ImpSp','ImpOrb','ImpSpOrb', 'BathSp','BathOrb','BathSpOrb'};%,'BathSp','BathOrb','BathSpOrb'};

    % zflag and cflag are options in getAdisc(fdmNRG calc. of the spectral func. of the correlation function)
    % zflag: to use(1) or not to use(0) fermionic sign change for each operator.
    % 1 for fermionic operators, 0 for bosonic operators (e.g. if Ops1 = [fermionic, bosonic], zflag = [1,0]
    zflag = zeros(1,numel(Ops1));     
    % cflag: sign factors for each commutator(+ for fermionic, - for bosonic operators)
    % corresponds to the purple sign factor in lecture note 16.2 of tensor networks course
    cflag = (zflag-0.5)*2;

    STG = ['/data/',getenv('USER'),'/TsoK/',JobName,'_Nkeep=',sprintf('%.15g',Nkeep),'_Lambda=',sprintf('%.15g',Lambda)];
    %STG = ['/data/',getenv('USER'),'/TsoK/TEST_Nk=3000_',JobName];

    Adiscs = cell(numel(Ops1),nz); % discrete data
    Aconts = cell(1,size(Adiscs,1)); % continuous (i.e., broadened) spectral function

    nrgdata = cell(1,nz);

    for itz = (1:nz)
      nrgdata{itz} = NRG_SL([],H0,A0,Lambda,ff{itz}(2:end),FF,ZF,'Nkeep',Nkeep,'deps',1e-10);

      if itz == nz
        [Etot,Qtot,Qdiff] = plotE(nrgdata{itz},'Emax',10,'legmax',25);       % Data for Eflow diagram

        save([STG,'/Etot.mat'],'Etot');
        save([STG,'/Qtot.mat'],'Qtot');
      end

      nrgdata{itz} = getRhoFDM(nrgdata{itz},T,'-v','Rdiag',true);   % calculating the full density matrix(FDM)

      if getSusc
        [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata{itz},Ops1,Ops2,ZF,'Z_L00',Z_imp,'zflag',zflag,'cflag',cflag,'emin',emin);
        % odisc: [Numeric vector] center values of the frequency grid
        % sigmak [Numeric vector] center values of the broadening width bins
        % Adiscs: [cell array of numeric matrix] spectral function binned along odisc
        % Adiscs(:,itz): cell vector of numeric matrix. 
        % nth matrix Adiscs(n,itz) corresponds to spectral function of Ops1(n) and Ops2(n) binned along odisc and sigmak
        % Length of cell vector Adisc(:,itz): numel(Ops1) = numel(Ops2)
      end
    end

    if getSusc

      DiscData.odisc = odisc;
      DiscData.sigmak = sigmak;
      DiscData.Adiscs = Adiscs;
      DiscData.nz = nz;
      DiscData.emin = emin;
      save([STG,'/DiscData.mat'],'DiscData');

      % file path to save Aconts
      SaveAconts = cellfun(@(x) [STG,'/NRG_Op=',OpNames{x},'.mat'], num2cell(1:numel(Ops1)), 'UniformOutput', false);

      % Calculate dynamic susceptibilities
      for ita = (1:size(Adiscs,1))

        Adisc = mean(cell2mat(reshape(Adiscs(ita,:),[1 1 nz])),3);

        [ocont, Aconts{ita}] = getAcont(odisc,Adisc,sigmak,T/5,'alphaz',1/nz,'emin',emin);
        % ocont : [numeric vector] Logarithimic frequency grid.
        % Aconts : [numeric vector] Smoothened spectral function.

        temp = Aconts{ita};
        save(SaveAconts{ita},'temp');
      end
      save([STG,'/ocont.mat'],'ocont');
      
    end

    %% calculate correlation functions between impurity and Wilson chain sites
    
    if getCorr

      Sp_corr = cell(N,1);        % cell array of spin-spin correlators between the impurity and Wilson chain sites
      Orb_corr = cell(N,1);       % cell array of orb-orb correlators between the impurity and Wilson chain sites
      SpOrb_corr = cell(N,1);     % cell array of spin-orb correlators between the impurity and Wilson chain sites
      
      Sp_corr_Left = S_sp;
      Orb_corr_Left = S_orb;
      SpOrb_corr_Left = S_sp_orb;
      
      for site = 0:N-2

        disptime(['Calculating correlator between impurity and Wilson chain site #',sprintf('%02d',site)]);
      
        Wilson_sp = setItag(['s',sprintf('%02d',site)],'op',J_sp);      % spin operator on Wilson chain site of interest
        Wilson_orb = setItag(['s',sprintf('%02d',site)],'op',J_orb);    % orbital psuedospin operator on Wilson chain site of interest
        Wilson_sporb = setItag(['s',sprintf('%02d',site)],'op',J_sp_orb);  % sp-orb operator on Wilson chain site of interest  


        Sp_corrT = contract(Sp_corr_Left, '!1', nrgdata{1}.AT{site+1}, '!2');
        Sp_corrT = contract(Sp_corrT, conj(Wilson_sp));
        Sp_corrT = contract(nrgdata{1}.AT{site+1}, '!2*', Sp_corrT);
      
        Sp_corrK = contract(Sp_corr_Left, '!1', nrgdata{1}.AK{site+1}, '!2');
        Sp_corrK = contract(Sp_corrK, conj(Wilson_sp));
        Sp_corrK = contract(nrgdata{1}.AK{site+1}, '!2*', Sp_corrK);
      

        Orb_corrT = contract(Orb_corr_Left, '!1', nrgdata{1}.AT{site+1}, '!2');
        Orb_corrT = contract(Orb_corrT, conj(Wilson_orb));
        Orb_corrT = contract(nrgdata{1}.AT{site+1}, '!2*', Orb_corrT);
      
        Orb_corrK = contract(Orb_corr_Left, '!1', nrgdata{1}.AK{site+1}, '!2');
        Orb_corrK = contract(Orb_corrK, conj(Wilson_orb));
        Orb_corrK = contract(nrgdata{1}.AK{site+1}, '!2*', Orb_corrK);


        SpOrb_corrT = contract(SpOrb_corr_Left, '!1', nrgdata{1}.AT{site+1}, '!2');
        SpOrb_corrT = contract(SpOrb_corrT, conj(Wilson_sporb));
        SpOrb_corrT = contract(nrgdata{1}.AT{site+1}, '!2*', SpOrb_corrT);
      
        SpOrb_corrK = contract(SpOrb_corr_Left, '!1', nrgdata{1}.AK{site+1}, '!2');
        SpOrb_corrK = contract(SpOrb_corrK, conj(Wilson_sporb));
        SpOrb_corrK = contract(nrgdata{1}.AK{site+1}, '!2*', SpOrb_corrK);
      

        Sp_corr{site+1} = 0;
        corrT = contract(Sp_corrT, diag(nrgdata{1}.RhoT{site+1}));
        corrK = contract(Sp_corrK, nrgdata{1}.RhoK{site+1});

        if ~isempty(corrT)
          Sp_corr{site+1} = Sp_corr{site+1} + corrT.data{1};
        end
          
        if ~isempty(corrK)
          Sp_corr{site+1} = Sp_corr{site+1} + corrK.data{1};
        end
      

        Orb_corr{site+1} = 0;
        corrT = contract(Orb_corrT, diag(nrgdata{1}.RhoT{site+1}));
        corrK = contract(Orb_corrK, nrgdata{1}.RhoK{site+1});

        if ~isempty(corrT)
          Orb_corr{site+1} = Orb_corr{site+1} + corrT.data{1};
        end

        if ~isempty(corrK)
          Orb_corr{site+1} = Orb_corr{site+1} + corrK.data{1};
        end


        SpOrb_corr{site+1} = 0;
        corrT = contract(SpOrb_corrT, diag(nrgdata{1}.RhoT{site+1}));
        corrK = contract(SpOrb_corrK, nrgdata{1}.RhoK{site+1});

        if ~isempty(corrT)
          SpOrb_corr{site+1} = SpOrb_corr{site+1} + corrT.data{1};
        end

        if ~isempty(corrK)
          SpOrb_corr{site+1} = SpOrb_corr{site+1} + corrK.data{1};
        end

        Sp_corr_Left = contract(Sp_corr_Left,'!1',nrgdata{1}.AK{site+1});
        Sp_corr_Left = contract(nrgdata{1}.AK{site+1},'!2*',Sp_corr_Left,[1,3,2]);

        Orb_corr_Left = contract(Orb_corr_Left,'!1',nrgdata{1}.AK{site+1});
        Orb_corr_Left = contract(nrgdata{1}.AK{site+1},'!2*',Orb_corr_Left,[1,3,2]);
            
        SpOrb_corr_Left = contract(SpOrb_corr_Left,'!1',nrgdata{1}.AK{site+1});
        SpOrb_corr_Left = contract(nrgdata{1}.AK{site+1},'!2*',SpOrb_corr_Left,[1,3,2]);
        
      end

      Sp_corr = cell2mat(Sp_corr);
      Orb_corr = cell2mat(Orb_corr);
      SpOrb_corr = cell2mat(SpOrb_corr);

      save([STG,'/Spin_correlators.mat'],'Sp_corr');
      save([STG,'/Orbital_correlators.mat'],'Orb_corr');
      save([STG,'/SpOrb_correlators.mat'],'SpOrb_corr');

    end % if getCorr


    %% calculate impurity contribution to entropy
    [ff, ~] = doZLD(ozin,RhoV2in,Lambda,N+10,1,'Nfit',round(-2*log(1e-8)/log(Lambda)));

    A02 = getIdentity(setItag('L00',getvac(E_imp)),2,Es,2,'K00*',[1 3 2]);
    H02 = contract(A02,'!2*',A02) + 1e-40*getIdentity(A02,2);
    bathNRG_data = NRG_SL([],H02,A02,Lambda,ff{1}(2:end),FF,ZF,'Nkeep',Nkeep,'deps',1e-10);
        
    beta = 1.5;
    [Temps,~,~,Sent_bath,~,~,~] = getTDconv(bathNRG_data,'useT','beta',beta);
    [~,~,~,Sent,~,~,~] = getTDconv(nrgdata{1},'useT','beta',beta);

    Sent = Sent(Temps > T);
    Sent_bath = Sent_bath(Temps > T);
    Sent_imp = Sent - Sent_bath;
    Temps = Temps(Temps > T);
    save([STG,'/Temps.mat'],'Temps');
    save([STG,'/Sent_imp.mat'],'Sent_imp');
  
  catch Err
      disp2(getReport(Err));
      rethrow(Err);
  end

end